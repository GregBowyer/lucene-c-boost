structural diffs
  - IntNRQ: stops collecting after first topN hits
  - sending MUST_NOT to BS

cache more reflection fields/methods!

must pass totalTF for all other places that use singleDocID

don't pull DocsEnum?  can't i get at the docIn separately?

add DOCS_ONLY TermQuery test

silly: TermQuery does not need to tie break on docID in its collect

why does TermRangeQuery not work?

run all Lucene tests again

convert live docs -> FixedBitSet?  so i can share code w/ filter ...

need to cherrypick which MUST queries are "appropriate" for BS1...

get omitNorms working

why is stddev not lower for C impls?

hmm TermsFilter?

hmm BooleanFilter?

remove register XXX

add test: termquery DOCS_ONLY: it should work but won't for silly reason...

instead of docIDs[slot] we can do docUpto + slot!  saves a mem ref, but adds an add

hmm only the LAST must clause needs to fill in numFilled!  don't bother filling for first N-1

PQ
  - why do we have both posUpto and posLeft?
  - must add the pos > lastPos check for same term at same position in a row!!
  - reverse the score function and don't consider a doc that cannot possible have high enough phraseFreq to compete w/ bottom
  - how should we sort the terms?
  - constant score query wrapped around it?
  - check positinos inside orLastMustChunk instead

MUST: we can re-compute filled every time!  so that we don't iterate over too many on each iter

Filter via acceptDocs

fix TermQuery !!  just do for loop over block size --> slower (strangely)

cutover to generic getField

add a "requireExactTotalHits" boolean

CSQ(TermQuery) can be massively optimized in the no deletes case!

hmm will this "starve" GC?

how to work across diff't lucene versions!?

make separate NativeMMapII impls for bounds checking (segments_N) and not?

later
  - really we should do the "checking" for all segs up-front, so we don't e.g. do lots of work on first segments only to discover a bad PF in the last one
    - or, do the native or not decision per-segment ... but this is uncommon

add madvise calls for merges to NativeMMapDir?

facets?

factor out common code in NativeSearch.java

why are there score iota diffs!

gen specialized decoders for x86!!!  horrible that I bswap on every load...

don't specialize decode above 24 bits?

write simd?

allow terms across different fields

make good random test

should i make just one JNI call, passing all segments down?  or, one JNI call per segment?

should we pre-share global stuff like byte[] norms?
